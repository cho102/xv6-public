diff --git a/.vscode/launch.json b/.vscode/launch.json
new file mode 100644
index 0000000..2148bf0
--- /dev/null
+++ b/.vscode/launch.json
@@ -0,0 +1,18 @@
+{
+    "version": "0.2.0",
+    "configurations": [
+        {
+            "type": "by-gdb",
+            "request": "launch",
+            "name": "Launch(remote)",
+            "program": "${workspaceRoot}/kernel",
+            "cwd": "${workspaceRoot}",
+            "remote": {
+                "enabled": true,
+                "address": ":28480",
+                "mode": "remote",
+                "execfile": "${workspaceRoot}/kernel"
+            }
+        }
+    ]
+}
\ No newline at end of file
diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..5f94f34
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,5 @@
+{
+    "files.associations": {
+        "types.h": "c"
+    }
+}
\ No newline at end of file
diff --git a/.vscode/tasks.json b/.vscode/tasks.json
new file mode 100644
index 0000000..106a3f1
--- /dev/null
+++ b/.vscode/tasks.json
@@ -0,0 +1,25 @@
+{
+    "version": "2.0.0",
+    "tasks": [
+        {
+            "label": "compile xv6 and run in debug mode",
+            "command": "bash",
+            "args": [
+                "-c",
+                "make && make qemu-nox-gdb"
+            ],
+            "presentation": {
+                "echo": true,
+                "reveal": "always",
+                "focus": true,
+                "panel": "new",
+                "showReuseMessage": true,
+                "clear": true
+            },
+            "group": {
+                "kind": "build",
+                "isDefault": true
+            }
+        }
+    ]
+}
\ No newline at end of file
diff --git a/Makefile b/Makefile
index 09d790c..d0611dd 100644
--- a/Makefile
+++ b/Makefile
@@ -181,6 +181,10 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_proc1\
+	_proc2\
+	_proc3\
+	_lab2test\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -217,7 +221,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 2
+CPUS := 1
 endif
 QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
 
@@ -283,4 +287,4 @@ tar:
 	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
 	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
 
-.PHONY: dist-test dist
+.PHONY: dist-test dist
\ No newline at end of file
diff --git a/bug.c b/bug.c
new file mode 100644
index 0000000..be576da
--- /dev/null
+++ b/bug.c
@@ -0,0 +1,9 @@
+#include "types.h"
+#include "user.h"
+
+int main(int argc, char* argv[])
+{
+    int val = 1234 / (argc -1);
+    printf(1,"%d\n", val);
+    exit();
+}
\ No newline at end of file
diff --git a/cat.c b/cat.c
index 5ddc820..ac8d2d3 100644
--- a/cat.c
+++ b/cat.c
@@ -40,4 +40,4 @@ main(int argc, char *argv[])
     close(fd);
   }
   exit();
-}
+}
\ No newline at end of file
diff --git a/code b/code
new file mode 100644
index 0000000..83d283e
--- /dev/null
+++ b/code
@@ -0,0 +1,805 @@
+diff --git a/.vscode/launch.json b/.vscode/launch.json
+new file mode 100644
+index 0000000..2148bf0
+--- /dev/null
++++ b/.vscode/launch.json
+@@ -0,0 +1,18 @@
++{
++    "version": "0.2.0",
++    "configurations": [
++        {
++            "type": "by-gdb",
++            "request": "launch",
++            "name": "Launch(remote)",
++            "program": "${workspaceRoot}/kernel",
++            "cwd": "${workspaceRoot}",
++            "remote": {
++                "enabled": true,
++                "address": ":28480",
++                "mode": "remote",
++                "execfile": "${workspaceRoot}/kernel"
++            }
++        }
++    ]
++}
+\ No newline at end of file
+diff --git a/.vscode/settings.json b/.vscode/settings.json
+new file mode 100644
+index 0000000..5f94f34
+--- /dev/null
++++ b/.vscode/settings.json
+@@ -0,0 +1,5 @@
++{
++    "files.associations": {
++        "types.h": "c"
++    }
++}
+\ No newline at end of file
+diff --git a/.vscode/tasks.json b/.vscode/tasks.json
+new file mode 100644
+index 0000000..106a3f1
+--- /dev/null
++++ b/.vscode/tasks.json
+@@ -0,0 +1,25 @@
++{
++    "version": "2.0.0",
++    "tasks": [
++        {
++            "label": "compile xv6 and run in debug mode",
++            "command": "bash",
++            "args": [
++                "-c",
++                "make && make qemu-nox-gdb"
++            ],
++            "presentation": {
++                "echo": true,
++                "reveal": "always",
++                "focus": true,
++                "panel": "new",
++                "showReuseMessage": true,
++                "clear": true
++            },
++            "group": {
++                "kind": "build",
++                "isDefault": true
++            }
++        }
++    ]
++}
+\ No newline at end of file
+diff --git a/Makefile b/Makefile
+index 09d790c..7c6f2f7 100644
+--- a/Makefile
++++ b/Makefile
+@@ -181,6 +181,9 @@ UPROGS=\
+ 	_usertests\
+ 	_wc\
+ 	_zombie\
++	_proc1\
++	_proc2\
++	_proc3\
+ 
+ fs.img: mkfs README $(UPROGS)
+ 	./mkfs fs.img README $(UPROGS)
+@@ -217,7 +220,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+ 	then echo "-gdb tcp::$(GDBPORT)"; \
+ 	else echo "-s -p $(GDBPORT)"; fi)
+ ifndef CPUS
+-CPUS := 2
++CPUS := 1
+ endif
+ QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+ 
+@@ -283,4 +286,4 @@ tar:
+ 	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+ 	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+ 
+-.PHONY: dist-test dist
++.PHONY: dist-test dist
+\ No newline at end of file
+diff --git a/bug.c b/bug.c
+new file mode 100644
+index 0000000..be576da
+--- /dev/null
++++ b/bug.c
+@@ -0,0 +1,9 @@
++#include "types.h"
++#include "user.h"
++
++int main(int argc, char* argv[])
++{
++    int val = 1234 / (argc -1);
++    printf(1,"%d\n", val);
++    exit();
++}
+\ No newline at end of file
+diff --git a/cat.c b/cat.c
+index 5ddc820..ac8d2d3 100644
+--- a/cat.c
++++ b/cat.c
+@@ -40,4 +40,4 @@ main(int argc, char *argv[])
+     close(fd);
+   }
+   exit();
+-}
++}
+\ No newline at end of file
+diff --git a/core.18571 b/core.18571
+new file mode 100644
+index 0000000..6babf4a
+Binary files /dev/null and b/core.18571 differ
+diff --git a/core.31960 b/core.31960
+new file mode 100644
+index 0000000..3661fbe
+Binary files /dev/null and b/core.31960 differ
+diff --git a/core.36446 b/core.36446
+new file mode 100644
+index 0000000..33e349b
+Binary files /dev/null and b/core.36446 differ
+diff --git a/defs.h b/defs.h
+index 82fb982..a791af2 100644
+--- a/defs.h
++++ b/defs.h
+@@ -120,6 +120,7 @@ void            userinit(void);
+ int             wait(void);
+ void            wakeup(void*);
+ void            yield(void);
++void            setprior(int);
+ 
+ // swtch.S
+ void            swtch(struct context**, struct context*);
+@@ -187,4 +188,4 @@ int             copyout(pde_t*, uint, void*, uint);
+ void            clearpteu(pde_t *pgdir, char *uva);
+ 
+ // number of elements in fixed-size array
+-#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
++#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
+\ No newline at end of file
+diff --git a/echo.c b/echo.c
+index 806dee0..d250102 100644
+--- a/echo.c
++++ b/echo.c
+@@ -10,4 +10,4 @@ main(int argc, char *argv[])
+   for(i = 1; i < argc; i++)
+     printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
+   exit();
+-}
++}
+\ No newline at end of file
+diff --git a/exec.c b/exec.c
+index b40134f..f88ca36 100644
+--- a/exec.c
++++ b/exec.c
+@@ -18,6 +18,7 @@ exec(char *path, char **argv)
+   struct proghdr ph;
+   pde_t *pgdir, *oldpgdir;
+   struct proc *curproc = myproc();
++  curproc->T_start = ticks;
+ 
+   begin_op();
+ 
+diff --git a/forktest.c b/forktest.c
+index 8bc984d..b831d8f 100644
+--- a/forktest.c
++++ b/forktest.c
+@@ -53,4 +53,4 @@ main(void)
+ {
+   forktest();
+   exit();
+-}
++}
+\ No newline at end of file
+diff --git a/grep.c b/grep.c
+index adc4835..99ac862 100644
+--- a/grep.c
++++ b/grep.c
+@@ -104,4 +104,3 @@ int matchstar(int c, char *re, char *text)
+   }while(*text!='\0' && (*text++==c || c=='.'));
+   return 0;
+ }
+-
+diff --git a/init.c b/init.c
+index 046b551..64c7bae 100644
+--- a/init.c
++++ b/init.c
+@@ -34,4 +34,4 @@ main(void)
+     while((wpid=wait()) >= 0 && wpid != pid)
+       printf(1, "zombie!\n");
+   }
+-}
++}
+\ No newline at end of file
+diff --git a/initcode.S b/initcode.S
+index 80ac5d8..70484db 100644
+--- a/initcode.S
++++ b/initcode.S
+@@ -29,4 +29,3 @@ init:
+ argv:
+   .long init
+   .long 0
+-
+diff --git a/kill.c b/kill.c
+index 364f6af..4599a35 100644
+--- a/kill.c
++++ b/kill.c
+@@ -14,4 +14,4 @@ main(int argc, char **argv)
+   for(i=1; i<argc; i++)
+     kill(atoi(argv[i]));
+   exit();
+-}
++}
+\ No newline at end of file
+diff --git a/lab1test.c b/lab1test.c
+new file mode 100644
+index 0000000..e50102a
+--- /dev/null
++++ b/lab1test.c
+@@ -0,0 +1,103 @@
++#include "types.h"
++#include "user.h"
++
++#define WNOHANG 	1
++
++int main(int argc, char *argv[])
++{
++	
++	int exitWait(void);
++	int waitPid(void);
++
++  printf(1, "\n This program tests the correctness of your lab#1\n");
++  
++  if (atoi(argv[1]) == 1)
++	exitWait();
++  else if (atoi(argv[1]) == 2)
++	waitPid();
++  else 
++   printf(1, "\ntype \"%s 1\" to test exit and wait, \"%s 2\" to test waitpid\n", argv[0], argv[0]);
++  
++    // End of test
++	 exit();
++	 return 0;
++ }
++  
++int exitWait(void) {
++	  int pid, ret_pid, exit_status;
++    int i;
++  // use this part to test exit(int status) and wait(int* status)
++ 
++  printf(1, "\n  Parts a & b) testing exit(int status) and wait(int* status):\n");
++
++  for (i = 0; i < 2; i++) {
++    pid = fork();
++    if (pid == 0) { // only the child executed this code
++      if (i == 0){
++        printf(1, "\nThis is child with PID# %d and I will exit with status %d\n", getpid(), 0);
++        exit();
++      }
++      else{
++	      printf(1, "\nThis is child with PID# %d and I will exit with status %d\n" ,getpid(), -1);
++        exit(-1);
++      } 
++    } else if (pid > 0) { // only the parent executes this code
++      ret_pid = wait(&exit_status);
++      printf(1, "\n This is the parent: child with PID# %d has exited with status %d\n", ret_pid, exit_status);
++    } else { // something went wrong with fork system call
++	    printf(2, "\nError using fork\n");
++      exit(-1);
++    }
++  }
++  return 0;
++}
++
++int waitPid(void){
++	
++  int ret_pid, exit_status;
++  int i;
++  int pid_a[5]={0, 0, 0, 0, 0};
++ // use this part to test wait(int pid, int* status, int options)
++
++  printf(1, "\n  Part c) testing waitpid(int pid, int* status, int options):\n");
++
++	for (i = 0; i <5; i++) {
++		pid_a[i] = fork();
++		if (pid_a[i] == 0) { // only the child executed this code
++			printf(1, "\n This is child with PID# %d and I will exit with status %d\n", getpid(), getpid() + 4);
++			exit(getpid() + 4);
++		}
++	}
++  sleep(5);
++  printf(1, "\n This is the parent: Now waiting for child with PID# %d\n",pid_a[3]);
++  ret_pid = waitpid(pid_a[3], &exit_status, 0);
++  printf(1, "\n This is the partent: Child# %d has exited with status %d, expected: %d\n",ret_pid, exit_status, pid_a[3] + 4);
++  sleep(5);
++  printf(1, "\n This is the parent: Now waiting for child with PID# %d\n",pid_a[1]);
++  ret_pid = waitpid(pid_a[1], &exit_status, 0);
++  printf(1, "\n This is the parent: Child# %d has exited with status %d, expected: %d\n",ret_pid, exit_status, pid_a[1] + 4);
++  sleep(5);
++  printf(1, "\n This is the parent: Now waiting for child with PID# %d\n",pid_a[2]);
++  ret_pid = waitpid(pid_a[2], &exit_status, 0);
++  printf(1, "\n This is the partent: Child# %d has exited with status %d, expected: %d\n",ret_pid, exit_status, pid_a[2] + 4);
++  sleep(5);
++  printf(1, "\n This is the parent: Now waiting for child with PID# %d\n",pid_a[0]);
++  ret_pid = waitpid(pid_a[0], &exit_status, 0);
++  printf(1, "\n This is the partent: Child# %d has exited with status %d, expected: %d\n",ret_pid, exit_status, pid_a[0] + 4);
++  sleep(5);
++  printf(1, "\n This is the parent: Now waiting for child with PID# %d\n",pid_a[4]);
++  ret_pid = waitpid(pid_a[4], &exit_status, 0);
++  printf(1, "\n This is the parent: Child# %d has exited with status %d, expected: %d\n",ret_pid, exit_status, pid_a[4] + 4);
++
++
++  printf(1, "\n This is the parent: Now try to wait for a invalid Number, this should not get stuck..\n");
++  ret_pid = waitpid(9999, &exit_status, 0);
++  printf(1, "\n This is the parent: Child# 9999 has ret code %d, expected: -1\n",ret_pid);
++  //printf(1, "\n This is the parent: Child# %d has exited with status %d\n",ret_pid, exit_status);
++
++  printf(1, "\n This is the parent: Now try to give invalid argument.\n");
++  ret_pid = waitpid(9999, (int*) 0xffffffff, 0);
++  printf(1, "\n This is the parent: Got ret code %d, expected: -1\n",ret_pid);
++
++  return 0;
++}
+diff --git a/ln.c b/ln.c
+index cf8a64e..ca7d86a 100644
+--- a/ln.c
++++ b/ln.c
+@@ -12,4 +12,4 @@ main(int argc, char *argv[])
+   if(link(argv[1], argv[2]) < 0)
+     printf(2, "link %s %s: failed\n", argv[1], argv[2]);
+   exit();
+-}
++}
+\ No newline at end of file
+diff --git a/ls.c b/ls.c
+index 2862913..33bd440 100644
+--- a/ls.c
++++ b/ls.c
+@@ -82,4 +82,4 @@ main(int argc, char *argv[])
+   for(i=1; i<argc; i++)
+     ls(argv[i]);
+   exit();
+-}
++}
+\ No newline at end of file
+diff --git a/mkdir.c b/mkdir.c
+index 6e4c954..aca060b 100644
+--- a/mkdir.c
++++ b/mkdir.c
+@@ -20,4 +20,4 @@ main(int argc, char *argv[])
+   }
+ 
+   exit();
+-}
++}
+\ No newline at end of file
+diff --git a/mkfs.c b/mkfs.c
+index 8e011a7..a0fe40e 100644
+--- a/mkfs.c
++++ b/mkfs.c
+@@ -294,4 +294,4 @@ iappend(uint inum, void *xp, int n)
+   }
+   din.size = xint(off);
+   winode(inum, &din);
+-}
++}
+\ No newline at end of file
+diff --git a/mycode.diff b/mycode.diff
+new file mode 100644
+index 0000000..6744303
+--- /dev/null
++++ b/mycode.diff
+@@ -0,0 +1,131 @@
++diff --git a/mycode.diff b/mycode.diff
++index ca75de6..e69de29 100644
++--- a/mycode.diff
+++++ b/mycode.diff
++@@ -1,126 +0,0 @@
++-diff --git a/.vscode/launch.json b/.vscode/launch.json
++-index 1a3d89d..2148bf0 100644
++---- a/.vscode/launch.json
++-+++ b/.vscode/launch.json
++-@@ -2,13 +2,17 @@
++-     "version": "0.2.0",
++-     "configurations": [
++-         {
++--            "type": "gdb",
++--            "request": "attach",
++--            "name": "debug xv6",
++--            "executable": "kernel",
++--            "target": ":26328",
++--            "remote": true,
++-+            "type": "by-gdb",
++-+            "request": "launch",
++-+            "name": "Launch(remote)",
++-+            "program": "${workspaceRoot}/kernel",
++-             "cwd": "${workspaceRoot}",
++-+            "remote": {
++-+                "enabled": true,
++-+                "address": ":28480",
++-+                "mode": "remote",
++-+                "execfile": "${workspaceRoot}/kernel"
++-+            }
++-         }
++-     ]
++- }
++-\ No newline at end of file
++-diff --git a/Makefile b/Makefile
++-index ef245d2..761b909 100644
++---- a/Makefile
++-+++ b/Makefile
++-@@ -76,7 +76,7 @@ AS = $(TOOLPREFIX)gas
++- LD = $(TOOLPREFIX)ld
++- OBJCOPY = $(TOOLPREFIX)objcopy
++- OBJDUMP = $(TOOLPREFIX)objdump
++--CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
++-+CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O0 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -gdwarf-2
++- CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
++- ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
++- # FreeBSD ld wants ``elf_i386_fbsd''
++-diff --git a/proc.c b/proc.c
++-index e70c5bd..7695652 100644
++---- a/proc.c
++-+++ b/proc.c
++-@@ -554,26 +554,30 @@ waitpid(int id, int *status, int options){
++-     // Scan through table looking for exited children.
++-     havekids = 0;
++-     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++--      if(p->parent != curproc) //p is 
++--        continue;
++--      havekids = 1;
++--    if(p->pid == id){}
++--      if(p->state == ZOMBIE){
++--        // Found one.
++--        pid = p->pid;
++--        kfree(p->kstack);
++--        p->kstack = 0;
++--        freevm(p->pgdir);
++--        p->pid = 0;
++--        p->parent = 0;
++--        p->name[0] = 0;
++--        p->killed = 0;
++--        p->state = UNUSED;
++--        release(&ptable.lock);
++--        return pid;
++-+      // if(p->parent != curproc) //p is 
++-+      //   continue;
++-+      if(p->pid == id){
++-+        havekids = 1;
++-+        if(p->state == ZOMBIE){
++-+          // Found one.
++-+          pid = p->pid;
++-+          kfree(p->kstack);
++-+          p->kstack = 0;
++-+          freevm(p->pgdir);
++-+          p->pid = 0;
++-+          p->parent = 0;
++-+          p->name[0] = 0;
++-+          p->killed = 0;
++-+          p->state = UNUSED;
++-+          *status = p->status;
++-+          // cprintf("%d %x\n", *status, status);
++-+          release(&ptable.lock);
++-+          return pid;
++-+        }
++-       }
++-     }
++- 
++-+
++-     // No point waiting if we don't have any children.
++-     if(!havekids || curproc->killed){
++-       release(&ptable.lock);
++-diff --git a/sysproc.c b/sysproc.c
++-index 2a053db..65c0280 100644
++---- a/sysproc.c
++-+++ b/sysproc.c
++-@@ -26,7 +26,7 @@ int
++- sys_wait(void)
++- {
++-   int *d;
++--  argptr(0,(char**)&d, sizeof(int*));
++-+  argptr(0,(char**)&d, 0);
++-   return wait(d);
++- }
++- 
++-@@ -102,8 +102,13 @@ sys_hello(void) {
++- 
++- int 
++- sys_waitpid(void){
++--  int pid = 1; 
++--  int options = 1;
++--  int status;
++--  return waitpid(pid, &status, options);
++-+  int pid; 
++-+  int options;
++-+  int* status;
++-+
++-+  argint(0, &pid);
++-+  argint(1, &options);
++-+  argptr(1,(char**)&status,0);
++-+
++-+  return waitpid(pid,status, options);
++- }
++-\ No newline at end of file
+diff --git a/proc.c b/proc.c
+index 806b1b1..39d14a9 100644
+--- a/proc.c
++++ b/proc.c
+@@ -112,6 +112,7 @@ found:
+   memset(p->context, 0, sizeof *p->context);
+   p->context->eip = (uint)forkret;
+ 
++  p->prior_val = 0;
+   return p;
+ }
+ 
+@@ -184,6 +185,7 @@ fork(void)
+   struct proc *np;
+   struct proc *curproc = myproc();
+ 
++  curproc->prior_val = 0;
+   // Allocate process.
+   if((np = allocproc()) == 0){
+     return -1;
+@@ -231,6 +233,12 @@ exit(void)
+   struct proc *p;
+   int fd;
+ 
++  // curproc->T_finish = ticks;
++  // int turnaround = curproc->T_finish - curproc->T_start;
++  // int waiting = turnaround - curproc->burst_time;
++  // cprintf("Turnaround time: %d ; Waiting time: %d\n", turnaround, waiting);
++
++
+   if(curproc == initproc)
+     panic("init exiting");
+ 
+@@ -326,15 +334,38 @@ scheduler(void)
+   struct cpu *c = mycpu();
+   c->proc = 0;
+   
++  int temp_high = 31;
++
+   for(;;){
+     // Enable interrupts on this processor.
+     sti();
+ 
+     // Loop over process table looking for process to run.
+     acquire(&ptable.lock);
++
++    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++      if (p->prior_val < temp_high){
++        temp_high = p->prior_val;
++      }
++    }
++
+     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+-      if(p->state != RUNNABLE)
++      
++      //MODIFY SCHEDULER
++      if((p->state != RUNNABLE)){
+         continue;
++      }
++
++      if((p->prior_val != temp_high)){
++        p->prior_val = p->prior_val -1;
++        continue;
++      }
++
++      
++      
++      // cprintf("p: %p \n", p);
++      p->prior_val = p->prior_val +1;
++      p->burst_time = p->burst_time+1;
+ 
+       // Switch to chosen process.  It is the process's job
+       // to release ptable.lock and then reacquire it
+@@ -532,3 +563,10 @@ procdump(void)
+     cprintf("\n");
+   }
+ }
++
++void setprior(int prior_lvl){
++  struct proc *curproc = myproc();
++  curproc->prior_val = prior_lvl;
++  curproc->burst_time = 0;
++  yield();
++}
+\ No newline at end of file
+diff --git a/proc.h b/proc.h
+index 1647114..9f601ed 100644
+--- a/proc.h
++++ b/proc.h
+@@ -49,10 +49,14 @@ struct proc {
+   struct file *ofile[NOFILE];  // Open files
+   struct inode *cwd;           // Current directory
+   char name[16];               // Process name (debugging)
++  int prior_val;
++  int T_finish;
++  int T_start;
++  int burst_time;
+ };
+ 
+ // Process memory is laid out contiguously, low addresses first:
+ //   text
+ //   original data and bss
+ //   fixed-size stack
+-//   expandable heap
++//   expandable heap
+\ No newline at end of file
+diff --git a/rm.c b/rm.c
+index 4fd33c8..69bc332 100644
+--- a/rm.c
++++ b/rm.c
+@@ -20,4 +20,4 @@ main(int argc, char *argv[])
+   }
+ 
+   exit();
+-}
++}
+\ No newline at end of file
+diff --git a/sh.c b/sh.c
+index 054bab9..52e559d 100644
+--- a/sh.c
++++ b/sh.c
+@@ -490,4 +490,4 @@ nulterminate(struct cmd *cmd)
+     break;
+   }
+   return cmd;
+-}
++}
+\ No newline at end of file
+diff --git a/stressfs.c b/stressfs.c
+index c0a4743..ae8b79a 100644
+--- a/stressfs.c
++++ b/stressfs.c
+@@ -46,4 +46,4 @@ main(int argc, char *argv[])
+   wait();
+ 
+   exit();
+-}
++}
+\ No newline at end of file
+diff --git a/syscall.c b/syscall.c
+index ee85261..15a048e 100644
+--- a/syscall.c
++++ b/syscall.c
+@@ -103,6 +103,7 @@ extern int sys_unlink(void);
+ extern int sys_wait(void);
+ extern int sys_write(void);
+ extern int sys_uptime(void);
++extern int sys_setprior(void);
+ 
+ static int (*syscalls[])(void) = {
+ [SYS_fork]    sys_fork,
+@@ -126,6 +127,7 @@ static int (*syscalls[])(void) = {
+ [SYS_link]    sys_link,
+ [SYS_mkdir]   sys_mkdir,
+ [SYS_close]   sys_close,
++[SYS_setprior]  sys_setprior,
+ };
+ 
+ void
+@@ -142,4 +144,4 @@ syscall(void)
+             curproc->pid, curproc->name, num);
+     curproc->tf->eax = -1;
+   }
+-}
++}
+\ No newline at end of file
+diff --git a/syscall.h b/syscall.h
+index bc5f356..cd295eb 100644
+--- a/syscall.h
++++ b/syscall.h
+@@ -20,3 +20,4 @@
+ #define SYS_link   19
+ #define SYS_mkdir  20
+ #define SYS_close  21
++#define SYS_setprior    22
+\ No newline at end of file
+diff --git a/sysproc.c b/sysproc.c
+index 0686d29..6483a13 100644
+--- a/sysproc.c
++++ b/sysproc.c
+@@ -89,3 +89,13 @@ sys_uptime(void)
+   release(&tickslock);
+   return xticks;
+ }
++
++int
++sys_setprior(void){
++  int prior_lvl;
++  if(argint(0, &prior_lvl)<0){
++    return -1;
++  }
++  setprior(prior_lvl);
++  return 0;
++}
+\ No newline at end of file
+diff --git a/test.c b/test.c
+new file mode 100644
+index 0000000..d3fa3fc
+--- /dev/null
++++ b/test.c
+@@ -0,0 +1,9 @@
++#include "types.h"
++#include "stat.h"
++#include "user.h"
++
++int main(int argc, char *argv[]){
++    //printf(1, hello world\n");
++    hello(); //J.H.
++    exit();
++}
+\ No newline at end of file
+diff --git a/trap.c b/trap.c
+index 41c66eb..a405841 100644
+--- a/trap.c
++++ b/trap.c
+@@ -109,4 +109,4 @@ trap(struct trapframe *tf)
+   // Check if the process has been killed since we yielded
+   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+     exit();
+-}
++}
+\ No newline at end of file
+diff --git a/user.h b/user.h
+index 4f99c52..9ab9603 100644
+--- a/user.h
++++ b/user.h
+@@ -23,6 +23,7 @@ int getpid(void);
+ char* sbrk(int);
+ int sleep(int);
+ int uptime(void);
++void setprior(int);
+ 
+ // ulib.c
+ int stat(const char*, struct stat*);
+@@ -36,4 +37,4 @@ uint strlen(const char*);
+ void* memset(void*, int, uint);
+ void* malloc(uint);
+ void free(void*);
+-int atoi(const char*);
++int atoi(const char*);
+\ No newline at end of file
+diff --git a/usertests.c b/usertests.c
+index a1e97e7..32213f3 100644
+--- a/usertests.c
++++ b/usertests.c
+@@ -1800,4 +1800,4 @@ main(int argc, char *argv[])
+   exectest();
+ 
+   exit();
+-}
++}
+\ No newline at end of file
+diff --git a/usys.S b/usys.S
+index 8bfd8a1..7902c2d 100644
+--- a/usys.S
++++ b/usys.S
+@@ -29,3 +29,4 @@ SYSCALL(getpid)
+ SYSCALL(sbrk)
+ SYSCALL(sleep)
+ SYSCALL(uptime)
++SYSCALL(setprior)
+\ No newline at end of file
+diff --git a/wc.c b/wc.c
+index d6a54df..aab2222 100644
+--- a/wc.c
++++ b/wc.c
+@@ -51,4 +51,4 @@ main(int argc, char *argv[])
+     close(fd);
+   }
+   exit();
+-}
++}
+\ No newline at end of file
+diff --git a/zombie.c b/zombie.c
+index ee817da..54b6479 100644
+--- a/zombie.c
++++ b/zombie.c
+@@ -11,4 +11,4 @@ main(void)
+   if(fork() > 0)
+     sleep(5);  // Let child exit before parent.
+   exit();
+-}
++}
+\ No newline at end of file
diff --git a/core.18571 b/core.18571
new file mode 100644
index 0000000..6babf4a
Binary files /dev/null and b/core.18571 differ
diff --git a/core.31960 b/core.31960
new file mode 100644
index 0000000..3661fbe
Binary files /dev/null and b/core.31960 differ
diff --git a/core.36446 b/core.36446
new file mode 100644
index 0000000..33e349b
Binary files /dev/null and b/core.36446 differ
diff --git a/defs.h b/defs.h
index 82fb982..a791af2 100644
--- a/defs.h
+++ b/defs.h
@@ -120,6 +120,7 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+void            setprior(int);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
@@ -187,4 +188,4 @@ int             copyout(pde_t*, uint, void*, uint);
 void            clearpteu(pde_t *pgdir, char *uva);
 
 // number of elements in fixed-size array
-#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
+#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
\ No newline at end of file
diff --git a/echo.c b/echo.c
index 806dee0..d250102 100644
--- a/echo.c
+++ b/echo.c
@@ -10,4 +10,4 @@ main(int argc, char *argv[])
   for(i = 1; i < argc; i++)
     printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
   exit();
-}
+}
\ No newline at end of file
diff --git a/exec.c b/exec.c
index b40134f..c1ab26f 100644
--- a/exec.c
+++ b/exec.c
@@ -21,6 +21,8 @@ exec(char *path, char **argv)
 
   begin_op();
 
+  curproc->T_start = ticks;
+
   if((ip = namei(path)) == 0){
     end_op();
     cprintf("exec: fail\n");
diff --git a/forktest.c b/forktest.c
index 8bc984d..b831d8f 100644
--- a/forktest.c
+++ b/forktest.c
@@ -53,4 +53,4 @@ main(void)
 {
   forktest();
   exit();
-}
+}
\ No newline at end of file
diff --git a/grep.c b/grep.c
index adc4835..99ac862 100644
--- a/grep.c
+++ b/grep.c
@@ -104,4 +104,3 @@ int matchstar(int c, char *re, char *text)
   }while(*text!='\0' && (*text++==c || c=='.'));
   return 0;
 }
-
diff --git a/init.c b/init.c
index 046b551..64c7bae 100644
--- a/init.c
+++ b/init.c
@@ -34,4 +34,4 @@ main(void)
     while((wpid=wait()) >= 0 && wpid != pid)
       printf(1, "zombie!\n");
   }
-}
+}
\ No newline at end of file
diff --git a/initcode.S b/initcode.S
index 80ac5d8..70484db 100644
--- a/initcode.S
+++ b/initcode.S
@@ -29,4 +29,3 @@ init:
 argv:
   .long init
   .long 0
-
diff --git a/kill.c b/kill.c
index 364f6af..4599a35 100644
--- a/kill.c
+++ b/kill.c
@@ -14,4 +14,4 @@ main(int argc, char **argv)
   for(i=1; i<argc; i++)
     kill(atoi(argv[i]));
   exit();
-}
+}
\ No newline at end of file
diff --git a/lab1test.c b/lab1test.c
new file mode 100644
index 0000000..e50102a
--- /dev/null
+++ b/lab1test.c
@@ -0,0 +1,103 @@
+#include "types.h"
+#include "user.h"
+
+#define WNOHANG 	1
+
+int main(int argc, char *argv[])
+{
+	
+	int exitWait(void);
+	int waitPid(void);
+
+  printf(1, "\n This program tests the correctness of your lab#1\n");
+  
+  if (atoi(argv[1]) == 1)
+	exitWait();
+  else if (atoi(argv[1]) == 2)
+	waitPid();
+  else 
+   printf(1, "\ntype \"%s 1\" to test exit and wait, \"%s 2\" to test waitpid\n", argv[0], argv[0]);
+  
+    // End of test
+	 exit();
+	 return 0;
+ }
+  
+int exitWait(void) {
+	  int pid, ret_pid, exit_status;
+    int i;
+  // use this part to test exit(int status) and wait(int* status)
+ 
+  printf(1, "\n  Parts a & b) testing exit(int status) and wait(int* status):\n");
+
+  for (i = 0; i < 2; i++) {
+    pid = fork();
+    if (pid == 0) { // only the child executed this code
+      if (i == 0){
+        printf(1, "\nThis is child with PID# %d and I will exit with status %d\n", getpid(), 0);
+        exit();
+      }
+      else{
+	      printf(1, "\nThis is child with PID# %d and I will exit with status %d\n" ,getpid(), -1);
+        exit(-1);
+      } 
+    } else if (pid > 0) { // only the parent executes this code
+      ret_pid = wait(&exit_status);
+      printf(1, "\n This is the parent: child with PID# %d has exited with status %d\n", ret_pid, exit_status);
+    } else { // something went wrong with fork system call
+	    printf(2, "\nError using fork\n");
+      exit(-1);
+    }
+  }
+  return 0;
+}
+
+int waitPid(void){
+	
+  int ret_pid, exit_status;
+  int i;
+  int pid_a[5]={0, 0, 0, 0, 0};
+ // use this part to test wait(int pid, int* status, int options)
+
+  printf(1, "\n  Part c) testing waitpid(int pid, int* status, int options):\n");
+
+	for (i = 0; i <5; i++) {
+		pid_a[i] = fork();
+		if (pid_a[i] == 0) { // only the child executed this code
+			printf(1, "\n This is child with PID# %d and I will exit with status %d\n", getpid(), getpid() + 4);
+			exit(getpid() + 4);
+		}
+	}
+  sleep(5);
+  printf(1, "\n This is the parent: Now waiting for child with PID# %d\n",pid_a[3]);
+  ret_pid = waitpid(pid_a[3], &exit_status, 0);
+  printf(1, "\n This is the partent: Child# %d has exited with status %d, expected: %d\n",ret_pid, exit_status, pid_a[3] + 4);
+  sleep(5);
+  printf(1, "\n This is the parent: Now waiting for child with PID# %d\n",pid_a[1]);
+  ret_pid = waitpid(pid_a[1], &exit_status, 0);
+  printf(1, "\n This is the parent: Child# %d has exited with status %d, expected: %d\n",ret_pid, exit_status, pid_a[1] + 4);
+  sleep(5);
+  printf(1, "\n This is the parent: Now waiting for child with PID# %d\n",pid_a[2]);
+  ret_pid = waitpid(pid_a[2], &exit_status, 0);
+  printf(1, "\n This is the partent: Child# %d has exited with status %d, expected: %d\n",ret_pid, exit_status, pid_a[2] + 4);
+  sleep(5);
+  printf(1, "\n This is the parent: Now waiting for child with PID# %d\n",pid_a[0]);
+  ret_pid = waitpid(pid_a[0], &exit_status, 0);
+  printf(1, "\n This is the partent: Child# %d has exited with status %d, expected: %d\n",ret_pid, exit_status, pid_a[0] + 4);
+  sleep(5);
+  printf(1, "\n This is the parent: Now waiting for child with PID# %d\n",pid_a[4]);
+  ret_pid = waitpid(pid_a[4], &exit_status, 0);
+  printf(1, "\n This is the parent: Child# %d has exited with status %d, expected: %d\n",ret_pid, exit_status, pid_a[4] + 4);
+
+
+  printf(1, "\n This is the parent: Now try to wait for a invalid Number, this should not get stuck..\n");
+  ret_pid = waitpid(9999, &exit_status, 0);
+  printf(1, "\n This is the parent: Child# 9999 has ret code %d, expected: -1\n",ret_pid);
+  //printf(1, "\n This is the parent: Child# %d has exited with status %d\n",ret_pid, exit_status);
+
+  printf(1, "\n This is the parent: Now try to give invalid argument.\n");
+  ret_pid = waitpid(9999, (int*) 0xffffffff, 0);
+  printf(1, "\n This is the parent: Got ret code %d, expected: -1\n",ret_pid);
+
+  return 0;
+}
diff --git a/lab2test.c b/lab2test.c
new file mode 100644
index 0000000..58dc478
--- /dev/null
+++ b/lab2test.c
@@ -0,0 +1,32 @@
+#include "types.h"
+#include "user.h"
+
+void work() {
+  int i,k;
+  for(i = 0; i < 43000; i++) {
+    for(k = 0; k < 43000; k++) {
+      asm("nop");
+    }
+  }
+}
+
+int main() {
+  setprior(0);
+  int i = 0;
+  int pid = 0;
+  for(i = 0; i < 3; i++) {
+    pid = fork();
+    if(!pid) {
+      setprior(i * 10);
+      work();
+      printf(0, "child %d done\n", getpid());
+      exit();
+    }
+  }
+  if(pid) {
+    for(i = 0; i < 3; i++)
+      wait();
+  }
+  printf(0, "parent %d done\n", getpid());
+  exit();
+}
diff --git a/ln.c b/ln.c
index cf8a64e..ca7d86a 100644
--- a/ln.c
+++ b/ln.c
@@ -12,4 +12,4 @@ main(int argc, char *argv[])
   if(link(argv[1], argv[2]) < 0)
     printf(2, "link %s %s: failed\n", argv[1], argv[2]);
   exit();
-}
+}
\ No newline at end of file
diff --git a/ls.c b/ls.c
index 2862913..33bd440 100644
--- a/ls.c
+++ b/ls.c
@@ -82,4 +82,4 @@ main(int argc, char *argv[])
   for(i=1; i<argc; i++)
     ls(argv[i]);
   exit();
-}
+}
\ No newline at end of file
diff --git a/mkdir.c b/mkdir.c
index 6e4c954..aca060b 100644
--- a/mkdir.c
+++ b/mkdir.c
@@ -20,4 +20,4 @@ main(int argc, char *argv[])
   }
 
   exit();
-}
+}
\ No newline at end of file
diff --git a/mkfs.c b/mkfs.c
index 8e011a7..a0fe40e 100644
--- a/mkfs.c
+++ b/mkfs.c
@@ -294,4 +294,4 @@ iappend(uint inum, void *xp, int n)
   }
   din.size = xint(off);
   winode(inum, &din);
-}
+}
\ No newline at end of file
diff --git a/mycode.diff b/mycode.diff
new file mode 100644
index 0000000..6744303
--- /dev/null
+++ b/mycode.diff
@@ -0,0 +1,131 @@
+diff --git a/mycode.diff b/mycode.diff
+index ca75de6..e69de29 100644
+--- a/mycode.diff
++++ b/mycode.diff
+@@ -1,126 +0,0 @@
+-diff --git a/.vscode/launch.json b/.vscode/launch.json
+-index 1a3d89d..2148bf0 100644
+---- a/.vscode/launch.json
+-+++ b/.vscode/launch.json
+-@@ -2,13 +2,17 @@
+-     "version": "0.2.0",
+-     "configurations": [
+-         {
+--            "type": "gdb",
+--            "request": "attach",
+--            "name": "debug xv6",
+--            "executable": "kernel",
+--            "target": ":26328",
+--            "remote": true,
+-+            "type": "by-gdb",
+-+            "request": "launch",
+-+            "name": "Launch(remote)",
+-+            "program": "${workspaceRoot}/kernel",
+-             "cwd": "${workspaceRoot}",
+-+            "remote": {
+-+                "enabled": true,
+-+                "address": ":28480",
+-+                "mode": "remote",
+-+                "execfile": "${workspaceRoot}/kernel"
+-+            }
+-         }
+-     ]
+- }
+-\ No newline at end of file
+-diff --git a/Makefile b/Makefile
+-index ef245d2..761b909 100644
+---- a/Makefile
+-+++ b/Makefile
+-@@ -76,7 +76,7 @@ AS = $(TOOLPREFIX)gas
+- LD = $(TOOLPREFIX)ld
+- OBJCOPY = $(TOOLPREFIX)objcopy
+- OBJDUMP = $(TOOLPREFIX)objdump
+--CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+-+CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O0 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -gdwarf-2
+- CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+- ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+- # FreeBSD ld wants ``elf_i386_fbsd''
+-diff --git a/proc.c b/proc.c
+-index e70c5bd..7695652 100644
+---- a/proc.c
+-+++ b/proc.c
+-@@ -554,26 +554,30 @@ waitpid(int id, int *status, int options){
+-     // Scan through table looking for exited children.
+-     havekids = 0;
+-     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+--      if(p->parent != curproc) //p is 
+--        continue;
+--      havekids = 1;
+--    if(p->pid == id){}
+--      if(p->state == ZOMBIE){
+--        // Found one.
+--        pid = p->pid;
+--        kfree(p->kstack);
+--        p->kstack = 0;
+--        freevm(p->pgdir);
+--        p->pid = 0;
+--        p->parent = 0;
+--        p->name[0] = 0;
+--        p->killed = 0;
+--        p->state = UNUSED;
+--        release(&ptable.lock);
+--        return pid;
+-+      // if(p->parent != curproc) //p is 
+-+      //   continue;
+-+      if(p->pid == id){
+-+        havekids = 1;
+-+        if(p->state == ZOMBIE){
+-+          // Found one.
+-+          pid = p->pid;
+-+          kfree(p->kstack);
+-+          p->kstack = 0;
+-+          freevm(p->pgdir);
+-+          p->pid = 0;
+-+          p->parent = 0;
+-+          p->name[0] = 0;
+-+          p->killed = 0;
+-+          p->state = UNUSED;
+-+          *status = p->status;
+-+          // cprintf("%d %x\n", *status, status);
+-+          release(&ptable.lock);
+-+          return pid;
+-+        }
+-       }
+-     }
+- 
+-+
+-     // No point waiting if we don't have any children.
+-     if(!havekids || curproc->killed){
+-       release(&ptable.lock);
+-diff --git a/sysproc.c b/sysproc.c
+-index 2a053db..65c0280 100644
+---- a/sysproc.c
+-+++ b/sysproc.c
+-@@ -26,7 +26,7 @@ int
+- sys_wait(void)
+- {
+-   int *d;
+--  argptr(0,(char**)&d, sizeof(int*));
+-+  argptr(0,(char**)&d, 0);
+-   return wait(d);
+- }
+- 
+-@@ -102,8 +102,13 @@ sys_hello(void) {
+- 
+- int 
+- sys_waitpid(void){
+--  int pid = 1; 
+--  int options = 1;
+--  int status;
+--  return waitpid(pid, &status, options);
+-+  int pid; 
+-+  int options;
+-+  int* status;
+-+
+-+  argint(0, &pid);
+-+  argint(1, &options);
+-+  argptr(1,(char**)&status,0);
+-+
+-+  return waitpid(pid,status, options);
+- }
+-\ No newline at end of file
diff --git a/proc.c b/proc.c
index 806b1b1..0fc81dc 100644
--- a/proc.c
+++ b/proc.c
@@ -112,6 +112,7 @@ found:
   memset(p->context, 0, sizeof *p->context);
   p->context->eip = (uint)forkret;
 
+  p->prior_val = 0;
   return p;
 }
 
@@ -184,6 +185,7 @@ fork(void)
   struct proc *np;
   struct proc *curproc = myproc();
 
+  curproc->prior_val = 0;
   // Allocate process.
   if((np = allocproc()) == 0){
     return -1;
@@ -231,6 +233,11 @@ exit(void)
   struct proc *p;
   int fd;
 
+  curproc->T_finish = ticks;
+  int turnaround = curproc->T_finish - curproc->T_start;
+  int waiting = turnaround - curproc->burst_time;
+  cprintf("Init Lvl: %d; Turnaround time: %d; Waiting time: %d\n", curproc->init_val, turnaround, waiting);
+
   if(curproc == initproc)
     panic("init exiting");
 
@@ -326,15 +333,38 @@ scheduler(void)
   struct cpu *c = mycpu();
   c->proc = 0;
   
+  int temp_high = 31;
+
   for(;;){
     // Enable interrupts on this processor.
     sti();
 
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
+
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if (p->prior_val < temp_high){
+        temp_high = p->prior_val;
+      }
+    }
+
     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
+      
+      //MODIFY SCHEDULER
+      if((p->state != RUNNABLE)){
         continue;
+      }
+
+      if((p->prior_val != temp_high)){
+        p->prior_val = p->prior_val -1;
+        continue;
+      }
+
+      
+      
+      // cprintf("p: %p \n", p);
+      p->prior_val = p->prior_val +1;
+      p->burst_time = p->burst_time+1;
 
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
@@ -532,3 +562,11 @@ procdump(void)
     cprintf("\n");
   }
 }
+
+void setprior(int prior_lvl){
+  struct proc *curproc = myproc();
+  curproc->prior_val = prior_lvl;
+  curproc->init_val = prior_lvl;
+  curproc->burst_time = 0;
+  yield();
+}
\ No newline at end of file
diff --git a/proc.h b/proc.h
index 1647114..7b99cff 100644
--- a/proc.h
+++ b/proc.h
@@ -49,10 +49,15 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int prior_val;
+  int T_finish;
+  int T_start;
+  int burst_time;
+  int init_val;
 };
 
 // Process memory is laid out contiguously, low addresses first:
 //   text
 //   original data and bss
 //   fixed-size stack
-//   expandable heap
+//   expandable heap
\ No newline at end of file
diff --git a/proc1.c b/proc1.c
new file mode 100644
index 0000000..eaf5401
--- /dev/null
+++ b/proc1.c
@@ -0,0 +1,15 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int main(int argc, char *argv[]){
+    setprior(5);
+    int i, k;
+    for (i = 0; i < 43000; i++){
+        asm("nop");
+        for (k=0; k < 43000; k++){
+            asm("nop");
+        }
+    }
+    exit();
+}
diff --git a/proc2.c b/proc2.c
new file mode 100644
index 0000000..1df785f
--- /dev/null
+++ b/proc2.c
@@ -0,0 +1,15 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int main(int argc, char *argv[]){
+    setprior(15);
+    int i, k;
+    for (i = 0; i < 43000; i++){
+        asm("nop");
+        for (k=0; k < 43000; k++){
+            asm("nop");
+        }
+    }
+    exit();
+}
\ No newline at end of file
diff --git a/proc3.c b/proc3.c
new file mode 100644
index 0000000..421d221
--- /dev/null
+++ b/proc3.c
@@ -0,0 +1,15 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int main(int argc, char *argv[]){
+    setprior(30);
+    int i, k;
+    for (i = 0; i < 43000; i++){
+        asm("nop");
+        for (k=0; k < 43000; k++){
+            asm("nop");
+        }
+    }
+    exit();
+}
\ No newline at end of file
diff --git a/rm.c b/rm.c
index 4fd33c8..69bc332 100644
--- a/rm.c
+++ b/rm.c
@@ -20,4 +20,4 @@ main(int argc, char *argv[])
   }
 
   exit();
-}
+}
\ No newline at end of file
diff --git a/sh.c b/sh.c
index 054bab9..52e559d 100644
--- a/sh.c
+++ b/sh.c
@@ -490,4 +490,4 @@ nulterminate(struct cmd *cmd)
     break;
   }
   return cmd;
-}
+}
\ No newline at end of file
diff --git a/stressfs.c b/stressfs.c
index c0a4743..ae8b79a 100644
--- a/stressfs.c
+++ b/stressfs.c
@@ -46,4 +46,4 @@ main(int argc, char *argv[])
   wait();
 
   exit();
-}
+}
\ No newline at end of file
diff --git a/syscall.c b/syscall.c
index ee85261..15a048e 100644
--- a/syscall.c
+++ b/syscall.c
@@ -103,6 +103,7 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_setprior(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +127,7 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_setprior]  sys_setprior,
 };
 
 void
@@ -142,4 +144,4 @@ syscall(void)
             curproc->pid, curproc->name, num);
     curproc->tf->eax = -1;
   }
-}
+}
\ No newline at end of file
diff --git a/syscall.h b/syscall.h
index bc5f356..cd295eb 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,4 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_setprior    22
\ No newline at end of file
diff --git a/sysproc.c b/sysproc.c
index 0686d29..6483a13 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -89,3 +89,13 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+int
+sys_setprior(void){
+  int prior_lvl;
+  if(argint(0, &prior_lvl)<0){
+    return -1;
+  }
+  setprior(prior_lvl);
+  return 0;
+}
\ No newline at end of file
diff --git a/test.c b/test.c
new file mode 100644
index 0000000..d3fa3fc
--- /dev/null
+++ b/test.c
@@ -0,0 +1,9 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int main(int argc, char *argv[]){
+    //printf(1, hello world\n");
+    hello(); //J.H.
+    exit();
+}
\ No newline at end of file
diff --git a/trap.c b/trap.c
index 41c66eb..a405841 100644
--- a/trap.c
+++ b/trap.c
@@ -109,4 +109,4 @@ trap(struct trapframe *tf)
   // Check if the process has been killed since we yielded
   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
     exit();
-}
+}
\ No newline at end of file
diff --git a/user.h b/user.h
index 4f99c52..9ab9603 100644
--- a/user.h
+++ b/user.h
@@ -23,6 +23,7 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+void setprior(int);
 
 // ulib.c
 int stat(const char*, struct stat*);
@@ -36,4 +37,4 @@ uint strlen(const char*);
 void* memset(void*, int, uint);
 void* malloc(uint);
 void free(void*);
-int atoi(const char*);
+int atoi(const char*);
\ No newline at end of file
diff --git a/usertests.c b/usertests.c
index a1e97e7..32213f3 100644
--- a/usertests.c
+++ b/usertests.c
@@ -1800,4 +1800,4 @@ main(int argc, char *argv[])
   exectest();
 
   exit();
-}
+}
\ No newline at end of file
diff --git a/usys.S b/usys.S
index 8bfd8a1..7902c2d 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,4 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(setprior)
\ No newline at end of file
diff --git a/wc.c b/wc.c
index d6a54df..aab2222 100644
--- a/wc.c
+++ b/wc.c
@@ -51,4 +51,4 @@ main(int argc, char *argv[])
     close(fd);
   }
   exit();
-}
+}
\ No newline at end of file
diff --git a/zombie.c b/zombie.c
index ee817da..54b6479 100644
--- a/zombie.c
+++ b/zombie.c
@@ -11,4 +11,4 @@ main(void)
   if(fork() > 0)
     sleep(5);  // Let child exit before parent.
   exit();
-}
+}
\ No newline at end of file
